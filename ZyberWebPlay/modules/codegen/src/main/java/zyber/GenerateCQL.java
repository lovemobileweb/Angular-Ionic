package zyber;

import java.io.File;
import java.io.FileInputStream;
import java.net.MalformedURLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.io.FileUtils;

import com.github.javaparser.JavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.ImportDeclaration;
import com.github.javaparser.ast.PackageDeclaration;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.FieldDeclaration;
import com.github.javaparser.ast.body.VariableDeclarator;
import com.github.javaparser.ast.expr.AnnotationExpr;
import com.github.javaparser.ast.expr.BinaryExpr;
import com.github.javaparser.ast.expr.BinaryExpr.Operator;
import com.github.javaparser.ast.expr.Expression;
import com.github.javaparser.ast.expr.FieldAccessExpr;
import com.github.javaparser.ast.expr.MarkerAnnotationExpr;
import com.github.javaparser.ast.expr.MemberValuePair;
import com.github.javaparser.ast.expr.NormalAnnotationExpr;
import com.github.javaparser.ast.expr.SingleMemberAnnotationExpr;
import com.github.javaparser.ast.expr.StringLiteralExpr;
import com.github.javaparser.ast.visitor.VoidVisitorAdapter;

public class GenerateCQL extends VoidVisitorAdapter<GenerateCQL.VisitorState> {
	static String gPackage = "zyber.server.dao";

	private static List<File> getFiles(String inputFolder)
			throws IllegalArgumentException, MalformedURLException {

		File folder = new File(inputFolder);

		File[] ret = folder.listFiles();
		Arrays.sort(ret);
		return Arrays.asList(ret);
	}

	public static void main(String... argsIn) throws Exception {
		// if (argsIn.length == 3) return;
		String[] args = argsIn;
		try {
			if (args.length == 0) {
				args = new String[] {
						"C:\\Dev\\Zyber\\zyber-zyber.zyber\\ZyberWebPlay\\app\\zyber\\server\\dao",
						"C:\\Dev\\Zyber\\zyber-zyber.zyber\\ZyberWebPlay\\conf\\zyber",
						"C:\\Dev\\Zyber\\zyber-zyber.zyber\\ZyberWebPlay\\modules\\codegen\\src\\main\\java\\zyber\\GenerateCQL.java" };
			}
			assert (args.length == 3);
			String inputFolder = args[0];
			String outputFolder = args[1];
			String generatorPath = args[2];

			GenerateCQL ga = new GenerateCQL();

			File out = new File(outputFolder, "ZyberGen.cql");
			File generatorSrc = new File(generatorPath);

			List<File> files = getFiles(inputFolder);

			boolean updateCql = isUpdateRequired(out, files, generatorSrc);
			if (!updateCql) {
				System.out.println("CQL generation skipped - file up to date");
				return;
			}

			for (File f : files) {
				if (f.isDirectory())
					continue;
				if (!f.getName().endsWith(".java"))
					continue;

				FileInputStream in = new FileInputStream(f);

				CompilationUnit cu;
				try {
					// parse the file
					cu = JavaParser.parse(in);
				} finally {
					in.close();
				}
				GenerateCQL.VisitorState vs = new GenerateCQL.VisitorState();
				vs.vars = new GenerateCQL.FindVariableDefn();
				vs.vars.visit(cu, null);
				ga.visit(cu, vs);
			}
			
			System.out.println("File generated: " + out + "\n\n"
					+ ga.cql.toString());
			FileUtils.writeStringToFile(out, ga.cql.toString());

		} catch (Exception e) {
			e.printStackTrace(System.err);
			throw new java.lang.IllegalStateException(
					"Printed error to stdout, and re-throwing.", e);
		}
	}

	private static boolean isUpdateRequired(File out, List<File> files,
			File generatorSrc) {
		if (!out.exists() || out.lastModified() < generatorSrc.lastModified())
			return true;

		for (File f : files) {
			if (out.lastModified() < f.lastModified()) {
				return true;
			}
		}
		return false;
	}

	StringBuffer cql = new StringBuffer("// CQL Generated by "
			+ getClass().getName() + "\n\n");

	// Generate accessors that are tenant specific by deleting the tenant
	// parameter from the call,
	// and then wrapping with a delegate call.
	/** declared by {@link class:FileVersion} */
	String implementingClassPackage;

	@Override
	public void visit(final PackageDeclaration n,
			final GenerateCQL.VisitorState arg) {
		implementingClassPackage = n.getName().toStringWithoutComments();
		super.visit(n, arg);
	}

	@Override
	public void visit(final ImportDeclaration n,
			final GenerateCQL.VisitorState arg) {
		super.visit(n, arg);
	}

	String tryToGetValue(GenerateCQL.VisitorState arg, Expression val) {
		if (val instanceof StringLiteralExpr) {
			String ret = ((StringLiteralExpr) val).getValue();
			// ret.replace(arg0, arg1)
			// ret = ret.replaceAll("\\n", "\n");

			while (ret.indexOf("\\n") != -1)
				ret = ret.replace("\\n", "\n");
			while (ret.indexOf("\\t") != -1)
				ret = ret.replace("\\t", "    ");
			while (ret.indexOf("\\\"") != -1)
				ret = ret.replace("\\\"", "\"");
			while (ret.indexOf("\\\'") != -1)
				ret = ret.replace("\\\"", "\'");
			return ret;
		}
		if (val instanceof BinaryExpr) {
			BinaryExpr be = (BinaryExpr) val;
			if (be.getOperator() == Operator.plus) {
				return tryToGetValue(arg, be.getLeft())
						+ tryToGetValue(arg, be.getRight());
			} else {
				return "Unsupported operator: " + be.getOperator();
			}
		}
		// if (val instanceof NameExpr) {
		//
		// NameExpr ne = (NameExpr)val;
		// if (arg.vars.staticVars.containsKey(ne.getName())) {
		// return tryToGetValue(arg, arg.vars.staticVars.get(ne.getName()));
		// } else {
		// return "Unknown variable: "+ne.getName();
		// }
		//
		// }
		if (val instanceof FieldAccessExpr) {

			FieldAccessExpr ne = (FieldAccessExpr) val;
			String qVarName = ne.toString();

			if (arg.vars.staticVars.containsKey(qVarName)) {
				return tryToGetValue(arg, arg.vars.staticVars.get(qVarName));
			} else {
				return "Unknown variable: " + qVarName;
			}

		}
		return "Unknown expression: " + val.getClass().getName();
	}

	@Override
	public void visit(final ClassOrInterfaceDeclaration n,
			final GenerateCQL.VisitorState arg) {

		// AnnotationExpr d = AnnotationExpr.class
		// n.getAnnotations();
		AnnotationExpr table = getFirstMatchingAnnotation(n.getAnnotations(),
				"Table");
		if (table == null)
			return;

		if (table instanceof NormalAnnotationExpr) {
			Map<String, Expression> mvps = getMemberValuePairs(((NormalAnnotationExpr) table)
					.getPairs());
			arg.tableName = tryToGetValue(arg, mvps.get("name"));
			arg.keyspace = tryToGetValue(arg, mvps.get("keyspace"));
			String tn = (arg.keyspace != null ? arg.keyspace + "." : "")
					+ arg.tableName;
			cql.append("CREATE TABLE " + tn + " (\n");
		} else {
			cql.append("Unsupported table annotation: "
					+ table.getClass().getName());
		}
		super.visit(n, arg);
		cql.append("    PRIMARY KEY ("
				+ "("
				+ String.join(", ", arg.partKey)
				+ ")"
				+ (arg.clusterKey.size() > 0 ? ", "
						+ String.join(", ", arg.clusterKey) : "") + ")\n");

		cql.append(");\n\n");

		if (arg.indexes.size() > 0) {
			for (String index : arg.indexes) {
				cql.append("CREATE INDEX " + arg.keyspace + "_" + arg.tableName
						+ "__" + index + " ON " + arg.keyspace + "."
						+ arg.tableName + "(" + index + ");\n");
			}
			cql.append("\n");
		}

		for (AnnotationExpr ca : n.getAnnotations()) {
			if (ca.getName().getName().equals("View")) {

				if (ca instanceof SingleMemberAnnotationExpr) {
					cql.append(tryToGetValue(arg,
							((SingleMemberAnnotationExpr) ca).getMemberValue())
							+ "\n");
				} else if (ca instanceof NormalAnnotationExpr) {
					Map<String, Expression> ai = getMemberValuePairs(((NormalAnnotationExpr) ca)
							.getPairs());
					cql.append(tryToGetValue(arg, ai.get("value")) + "\n");
				} else {
					cql.append("Unsupported annotation type for View in "
							+ getClass().getName() + ": " + arg.tableName);
				}
			}
		}
	}

	String mapType(String type) {
		if (type.endsWith("String"))
			return "text";
		if (type.endsWith("UUID"))
			return "uuid";
		if (type.endsWith("Integer"))
			return "int";
		if (type.endsWith("Date"))
			return "timestamp";
		if (type.endsWith("ByteBuffer"))
			return "blob";
		if (type.toLowerCase().endsWith("boolean"))
			return "boolean";
		if (type.toLowerCase().endsWith("int"))
			return "int";
		if (type.toLowerCase().endsWith("integer"))
			return "int";
		if (type.endsWith("long"))
			return "bigint";
		if (type.equals("Set<String>"))
			return "set<text>";
		return "text /* " + type + "*/";
	}

	@Override
	public void visit(FieldDeclaration n, final GenerateCQL.VisitorState arg) {
		// super.visit(n, arg);
		if (n.toString().indexOf("final") != -1)
			return;
		if (n.toString().indexOf("static") != -1)
			return;
		if (getFirstMatchingAnnotation(n.getAnnotations(), "Transient") != null)
			return;

		String type = n.getType().toStringWithoutComments();
		for (VariableDeclarator x : n.getVariables()) {
			String name;

			AnnotationExpr ca = getFirstMatchingAnnotation(n.getAnnotations(),
					"Column");
			if (ca == null) {
				name = x.getId().getName();
			} else if (ca instanceof SingleMemberAnnotationExpr) {
				name = "asdfasfasdfas"
						+ ((SingleMemberAnnotationExpr) ca).getName().getName();
			} else if (ca instanceof NormalAnnotationExpr) {
				Map<String, Expression> ai = getMemberValuePairs(((NormalAnnotationExpr) ca)
						.getPairs());
				name = tryToGetValue(arg, ai.get("name"));
			} else {
				name = "Unsupported annotation type in " + getClass().getName()
						+ ": " + ca.getClass().getName();
			}

			AnnotationExpr index = getFirstMatchingAnnotation(
					n.getAnnotations(), "Index");
			if (index != null) {
				arg.indexes.add(name);
			}

			cql.append("  " + name + " " + mapType(type) + ",\n");

			AnnotationExpr partKey = getFirstMatchingAnnotation(
					n.getAnnotations(), "PartitionKey");
			int partKeyIndex = -1;
			if (partKey == null) {
			} else if (partKey instanceof NormalAnnotationExpr) {
				Map<String, Expression> ai = getMemberValuePairs(((NormalAnnotationExpr) partKey)
						.getPairs());
				partKeyIndex = Integer.parseInt(tryToGetValue(arg,
						ai.get("name")));
			} else if (partKey instanceof MarkerAnnotationExpr) {
				partKeyIndex = arg.partKey.size();
			} else if (partKey instanceof SingleMemberAnnotationExpr) {
				partKeyIndex = Integer
						.parseInt(((SingleMemberAnnotationExpr) partKey)
								.getMemberValue().toString());
			} else {
				cql.append("Unsupported part key annontation: "
						+ partKey.getClass().getName());
			}

			if (partKeyIndex != -1) {
				while (arg.partKey.size() <= partKeyIndex)
					arg.partKey.add("?");
				arg.partKey.set(partKeyIndex, name);
			}

			AnnotationExpr clusterKey = getFirstMatchingAnnotation(
					n.getAnnotations(), "ClusteringColumn");
			int clusterKeyIndex = -1;
			if (clusterKey == null) {
			} else if (clusterKey instanceof NormalAnnotationExpr) {
				Map<String, Expression> ai = getMemberValuePairs(((NormalAnnotationExpr) partKey)
						.getPairs());
				clusterKeyIndex = Integer.parseInt(tryToGetValue(arg,
						ai.get("name")));
			} else if (clusterKey instanceof MarkerAnnotationExpr) {
				clusterKeyIndex = arg.clusterKey.size();
			} else if (clusterKey instanceof SingleMemberAnnotationExpr) {
				clusterKeyIndex = Integer
						.parseInt(((SingleMemberAnnotationExpr) clusterKey)
								.getMemberValue().toString());
			} else {
				cql.append("Unsupported cluster key annontation: "
						+ partKey.getClass().getName());
			}

			if (clusterKeyIndex != -1) {
				while (arg.clusterKey.size() <= clusterKeyIndex)
					arg.clusterKey.add("?");
				arg.clusterKey.set(clusterKeyIndex, name);
			}

		}

	}

	private Map<String, Expression> getMemberValuePairs(
			List<MemberValuePair> list) {
		HashMap<String, Expression> ret = new HashMap<String, Expression>();
		for (MemberValuePair x : list) {
			ret.put(x.getName(), x.getValue());
		}
		return ret;
	}

	private AnnotationExpr getFirstMatchingAnnotation(
			List<AnnotationExpr> anno, String typeToFind) {
		if (anno == null)
			return null;
		for (AnnotationExpr a : anno) {
			if (a.getName().getName().equals(typeToFind)) {
				return a;
			}
		}
		return null;
	}

	// Generate a mapper that set's the tenant on save/load.
	static class VisitorState {
		String tableName;
		String keyspace;
		ArrayList<String> partKey = new ArrayList<String>();
		ArrayList<String> clusterKey = new ArrayList<String>();
		ArrayList<String> indexes = new ArrayList<String>();
		FindVariableDefn vars;
	}

	static class FindVariableDefn extends VoidVisitorAdapter<Boolean> {
		public Map<String, Expression> staticVars = new HashMap<String, Expression>();
		String className;

		@Override
		public void visit(final ClassOrInterfaceDeclaration n, final Boolean arg) {
			className = n.getName();
			super.visit(n, arg);
		}

		@Override
		public void visit(FieldDeclaration n, Boolean arg) {
			super.visit(n, arg);

			if (n.toString().indexOf("static") == -1)
				return;
			if (n.toString().indexOf("String") == -1)
				return;
			// System.out.println("Assign: "+n);
			for (VariableDeclarator x : n.getVariables()) {
				// System.out.println("... "+x.getId()+"... "+x.getInit());
				staticVars.put(className + "." + x.getId().getName(),
						x.getInit());
			}

		}

	}

}
